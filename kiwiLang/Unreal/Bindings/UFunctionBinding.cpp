kiwiLang/src/kiwiLang/Unreal/Bindings/UFunctionBinding.cpp
#include "kiwiLang/Unreal/Bindings/UFunctionBinding.h"
#include "kiwiLang/Unreal/Bindings/UObjectRegistry.h"
#include "kiwiLang/Unreal/Types/UETypeConverter.h"
#include "kiwiLang/Diagnostics/DiagnosticEngine.h"
#include <sstream>

namespace kiwiLang {
namespace Unreal {

UFunctionBindingBase::UFunctionBindingBase(const UEFunctionBindingParams& params)
    : params_(params), isBound_(false), isValid_(false) {
}

UFunctionBindingBase::~UFunctionBindingBase() = default;

bool UEFunctionBindingParams::validate() const {
    if (functionName.empty()) {
        DiagnosticEngine::get().error("Function name cannot be empty");
        return false;
    }
    
    if (!kiwiFunction && ueFunctionInfo.name.empty()) {
        DiagnosticEngine::get().error("Function must have kiwiFunction or ueFunctionInfo");
        return false;
    }
    
    return true;
}

std::string UEFunctionBindingParams::generateSignature(const UETypeConverter& converter) const {
    std::ostringstream oss;
    
    if (returnType) {
        std::string returnTypeName = converter.getUETypeName(returnType);
        if (!returnTypeName.empty()) {
            oss << returnTypeName << " ";
        } else {
            oss << "void ";
        }
    } else {
        oss << "void ";
    }
    
    oss << functionName << "(";
    
    for (size_t i = 0; i < paramTypes.size(); ++i) {
        std::string paramTypeName = converter.getUETypeName(paramTypes[i]);
        if (paramTypeName.empty()) {
            paramTypeName = "void*";
        }
        
        oss << paramTypeName << " " << paramNames[i];
        
        if (i != paramTypes.size() - 1) {
            oss << ", ";
        }
    }
    
    oss << ")";
    
    if (isConst) {
        oss << " const";
    }
    
    return oss.str();
}

template<typename ReturnType, typename... Args>
bool UFunctionBinding<ReturnType, Args...>::bindToUFunction(UFunction* uFunction) {
    if (!uFunction) {
        DiagnosticEngine::get().error("Cannot bind to null UFunction");
        return false;
    }
    
    DiagnosticEngine::get().info("Binding function " + params_.functionName + " to UFunction");
 r with UE reflection system
    
    isBound_ = true;
    return true;
}

template<typename ReturnType, typename... Args>
bool UFunctionBinding<ReturnType, Args...>::bindToBlueprintGraph(void* blueprintFunction) {
    DiagnosticEngine::get().info("Binding function " + params_.functionName + " to blueprint graph");

    isBound_ = true;
    return true;
}

template<typename ReturnType, typename... Args>
std::string UFunctionBinding<ReturnType, Args...>::generateCPPWrapper() const {
    std::ostringstream oss;
    
    oss << "// Generated wrapper for function: " << params_.functionName << "\n";
    oss << "// DO NOT EDIT - Generated by kiwiLang\n\n";
    
    // Function signature
    oss << "template<typename... Args>\n";
    oss << "auto " << params_.functionName << "Wrapper(void* Object, Args... args) -> decltype(auto)\n";
    oss << "{\n";
    oss << "    if (!Object) {\n";
    
    if constexpr (!std::is_same_v<ReturnType, void>) {
        oss << "        return ReturnType{};\n";
    } else {
        oss << "        return;\n";
    }
    
    oss << "    }\n\n";
    
    oss << "    auto* NativeObject = static_cast<NativeClass*>(Object);\n";
    
    if (functionPtr_) {
        oss << "    ";
        if constexpr (!std::is_same_v<ReturnType, void>) {
            oss << "return ";
        }
        oss << "functionPtr_(NativeObject, std::forward<Args>(args)...);\n";
    } else if (memberFunctionPtr_ && objectInstance_) {
        oss << "    ";
        if constexpr (!std::is_same_v<ReturnType, void>) {
            oss << "return ";
        }
        oss << "memberFunctionPtr_(objectInstance_, NativeObject, std::forward<Args>(args)...);\n";
    } else if (nativeFunction_) {
        oss << "    ";
        if constexpr (!std::is_same_v<ReturnType, void>) {
            oss << "return ";
        }
        oss << "nativeFunction_(std::forward<Args>(args)...);\n";
    } else {
        oss << "    // No function bound\n";
        if constexpr (!std::is_same_v<ReturnType, void>) {
            oss << "    return ReturnType{};\n";
        }
    }
    
    oss << "}\n";
    
    return oss.str();
}

template<typename ReturnType, typename... Args>
std::string UFunctionBinding<ReturnType, Args...>::generateNativeThunk() const {
    std::ostringstream oss;
    
    oss << "// Native thunk for function: " << params_.functionName << "\n";
    oss << "// DO NOT EDIT - Generated by kiwiLang\n\n";
    
    oss << "DEFINE_FUNCTION(" << params_.functionName << "Thunk)\n";
    oss << "{\n";
    oss << "    P_GET_OBJECT(UObject, Context);\n";
    
    // Parameter parsing
    for (size_t i = 0; i < params_.paramTypes.size(); ++i) {
        const auto& param = params_.ueFunctionInfo.parameters[i];
        std::string paramType = param.type ? "void*" : "Unknown";
        
        oss << "    P_GET_" << paramType << "(" << param.name << ");\n";
    }
    
    oss << "\n";
    oss << "    P_FINISH;\n\n";
    
    oss << "    if (!Context) {\n";
    oss << "        return;\n";
    oss << "    }\n\n";
    
    oss << "    auto* Wrapper = GetFunctionWrapper(Context);\n";
    oss << "    if (!Wrapper) {\n";
    oss << "        return;\n";
    oss << "    }\n\n";
    
    // Call the wrapper
    oss << "    ";
    if constexpr (!std::is_same_v<ReturnType, void>) {
        oss << "ReturnType Result = ";
    }
    oss << "Wrapper->" << params_.functionName << "(";
    
    for (size_t i = 0; i < params_.paramNames.size(); ++i) {
        oss << params_.paramNames[i];
        if (i != params_.paramNames.size() - 1) {
            oss << ", ";
        }
    }
    
    oss << ");\n\n";
    
    // Set return value
    if constexpr (!std::is_same_v<ReturnType, void>) {
        oss << "    *(ReturnType*)RESULT_PARAM = Result;\n";
    }
    
    oss << "}\n";
    
    return oss.str();
}

template<typename ReturnType, typename... Args>
std::string UFunctionBinding<ReturnType, Args...>::generateBlueprintDispatcher() const {
    std::ostringstream oss;
    
    oss << "// Blueprint dispatcher for function: " << params_.functionName << "\n";
    oss << "// DO NOT EDIT - Generated by kiwiLang\n\n";
    
    oss << "void U" << params_.functionName << "Dispatcher::Execute()\n";
    oss << "{\n";
    oss << "    if (!IsValid(ContextObject)) {\n";
    oss << "        return;\n";
    oss << "    }\n\n";
    
    oss << "    // Dispatch to appropriate implementation\n";
    oss << "    if (ContextObject->Implements<UKiwiLangInterface>()) {\n";
    oss << "        IKiwiLangInterface::Execute_" << params_.functionName << "(ContextObject";
    
    for (const auto& paramName : params_.paramNames) {
        oss << ", " << paramName;
    }
    
    oss << ");\n";
    oss << "    } else {\n";
    oss << "        // Fallback to reflection\n";
    oss << "        UFunction* Function = ContextObject->FindFunction(FName(TEXT(\"" << params_.functionName << "\")));\n";
    oss << "        if (Function) {\n";
    oss << "            ContextObject->ProcessEvent(Function, Params);\n";
    oss << "        }\n";
    oss << "    }\n";
    oss << "}\n";
    
    return oss.str();
}

std::unique_ptr<UFunctionBindingBase> UFunctionBindingFactory::createBinding(
    const UEFunctionBindingParams& params,
    const UEBindingContext& context) {
    
    if (!params.validate()) {
        DiagnosticEngine::get().error("Invalid function binding parameters");
        return nullptr;
    }
    
    DiagnosticEngine::get().info("Creating function binding for: " + params.functionName);
    
    // later add all.
    auto binding = std::make_unique<UFunctionBinding<void, void*>>(params);
    configureTypedBinding(binding.get(), context);
    
    return binding;
}

template<typename ReturnType, typename... Args>
std::unique_ptr<UFunctionBinding<ReturnType, Args...>>
UFunctionBindingFactory::createTypedBinding(const UEFunctionBindingParams& params,
                                           typename UFunctionBinding<ReturnType, Args...>::FunctionPtr funcPtr,
                                           const UEBindingContext& context) {
    auto binding = std::make_unique<UFunctionBinding<ReturnType, Args...>>(params, funcPtr);
    configureTypedBinding(binding.get(), context);
    return binding;
}

bool UFunctionBindingFactory::validateFunctionCompatibility(
    const UEFunctionBindingParams& params,
    AST::FunctionDecl* kiwiFunction,
    const UETypeConverter& converter) {
    
    if (!kiwiFunction || !params.kiwiFunction) {
        return false;
    }
    
    // Check parameter count
    if (kiwiFunction->getParams().size() != params.paramTypes.size()) {
        DiagnosticEngine::get().error("Parameter count mismatch");
        return false;
    }
    
    // Check return type compatibility
    if (!converter.validateTypeCompatibility(
            kiwiFunction->getReturnType(),
            converter.getUETypeName(params.returnType),
            UETypeConversionFlags::Default)) {
        DiagnosticEngine::get().error("Return type incompatible");
        return false;
    }
    
    // Check parameter type compatibility
    for (size_t i = 0; i < kiwiFunction->getParams().size(); ++i) {
        auto kiwiParamType = kiwiFunction->getParams()[i]->getType();
        auto ueParamType = params.paramTypes[i];
        
        if (!converter.validateTypeCompatibility(
                kiwiParamType,
                converter.getUETypeName(ueParamType),
                UETypeConversionFlags::Default)) {
            DiagnosticEngine::get().error("Parameter type mismatch at index " + std::to_string(i));
            return false;
        }
    }
    
    return true;
}

void UFunctionBindingFactory::configureTypedBinding(UFunctionBindingBase* binding,
                                                   const UEBindingContext& context) {
    if (!binding || !context.registry) {
        return;
    }
    
    DiagnosticEngine::get().info("Configuring typed function binding for: " + binding->getParams().functionName);
    
    // Validate the binding
    if (!binding->isValid()) {
        DiagnosticEngine::get().error("Function binding is invalid");
        return;
    }
    
    // Register with object registry if needed
    if (context.registry) {
        // context.registry->registerFunctionBinding(std::unique_ptr<UFunctionBindingBase>(binding));
        // Note: This would need to handle ownership properly
    }
}

AST::TypePtr UFunctionBindingFactory::convertUETypeToKiwi(const std::string& ueTypeName,
                                                         const UETypeConverter& converter) {
    return converter.getKiwiType(ueTypeName);
}

std::string UFunctionBindingFactory::convertKiwiTypeToUE(AST::TypePtr kiwiType,
                                                        const UETypeConverter& converter) {
    return converter.getUETypeName(kiwiType);
}

// Explicit template instantiations for common function types
template class UFunctionBinding<void>;
template class UFunctionBinding<void, void*>;
template class UFunctionBinding<void, void*, void*>;
template class UFunctionBinding<void, void*, void*, void*>;
template class UFunctionBinding<int32_t>;
template class UFunctionBinding<int32_t, void*>;
template class UFunctionBinding<float>;
template class UFunctionBinding<float, void*>;
template class UFunctionBinding<bool>;
template class UFunctionBinding<bool, void*>;
template class UFunctionBinding<FString>;
template class UFunctionBinding<FString, void*>;

} // namespace Unreal
} // namespace kiwiLang