#include "kiwiLang/Unreal/Bindings/UClassBinding.h"
#include "kiwiLang/Unreal/Bindings/UObjectRegistry.h"
#include "kiwiLang/Diagnostics/DiagnosticEngine.h"
#include <sstream>

namespace kiwiLang {
namespace Unreal {

UClassBindingBase::UClassBindingBase(const UEClassInfo& classInfo)
    : classInfo_(classInfo) {
    collectProperties();
    collectFunctions();
}

UClassBindingBase::~UClassBindingBase() = default;

bool UClassBindingBase::hasProperty(const std::string& name) const {
    return std::any_of(properties_.begin(), properties_.end(),
        [&](const UEPropertyInfo* prop) {
            return prop->name == name;
        });
}

bool UClassBindingBase::hasFunction(const std::string& name) const {
    return std::any_of(functions_.begin(), functions_.end(),
        [&](const UEFunctionInfo* func) {
            return func->name == name;
        });
}

void UClassBindingBase::collectProperties() {
    properties_.clear();
    for (const auto& prop : classInfo_.properties) {
        properties_.push_back(&prop);
    }
}

void UClassBindingBase::collectFunctions() {
    functions_.clear();
    for (const auto& func : classInfo_.functions) {
        functions_.push_back(&func);
    }
}

template<typename NativeClass, typename KiwiClass>
std::string UClassBinding<NativeClass, KiwiClass>::generateNativeWrapper() const {
    std::ostringstream oss;
    
    oss << "// Generated wrapper for class: " << classInfo_.name << "\n";
    oss << "// DO NOT EDIT - Generated by kiwiLang\n\n";
    
    oss << "#pragma once\n\n";
    oss << "#include \"CoreMinimal.h\"\n";
    oss << "#include \"" << classInfo_.name << ".generated.h\"\n\n";
    
    oss << "UCLASS(BlueprintType, Blueprintable)\n";
    oss << "class " << classInfo_.getGeneratedClassName() << " : public " << classInfo_.baseClassName << "\n";
    oss << "{\n";
    oss << "    GENERATED_BODY()\n\n";
    oss << "public:\n";
    
    // Constructor
    oss << "    " << classInfo_.getGeneratedClassName() << "();\n\n";
    
    // Properties
    for (const auto& prop : classInfo_.properties) {
        if (prop.isBlueprintVisible()) {
            oss << "    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"" << prop.category << "\")\n";
            oss << "    " << prop.getCPPTypeName(*static_cast<const UETypeConverter*>(nullptr)) << " " << prop.name << ";\n\n";
        }
    }
    
    // Functions
    for (const auto& func : classInfo_.functions) {
        if (func.isBlueprintCallable()) {
            oss << "    UFUNCTION(BlueprintCallable, Category=\"" << func.category << "\")\n";
            oss << "    " << func.getSignature(*static_cast<const UETypeConverter*>(nullptr)) << ";\n\n";
        }
    }
    
    oss << "protected:\n";
    oss << "    virtual void BeginPlay() override;\n";
    oss << "    virtual void Tick(float DeltaTime) override;\n\n";
    
    oss << "private:\n";
    oss << "    // Native implementation\n";
    oss << "    NativeClass* NativeInstance;\n";
    oss << "};\n";
    
    return oss.str();
}

template<typename NativeClass, typename KiwiClass>
std::string UClassBinding<NativeClass, KiwiClass>::generateNativeHeader() const {
    std::ostringstream oss;
    
    oss << "// Native header for class: " << classInfo_.name << "\n";
    oss << "// DO NOT EDIT - Generated by kiwiLang\n\n";
    
    oss << "#pragma once\n\n";
    oss << "#include \"CoreMinimal.h\"\n";
    oss << "#include \"" << classInfo_.name << ".h\"\n\n";
    
    oss << "class Native" << classInfo_.getGeneratedClassName() << "\n";
    oss << "{\n";
    oss << "public:\n";
    oss << "    Native" << classInfo_.getGeneratedClassName() << "();\n";
    oss << "    ~Native" << classInfo_.getGeneratedClassName() << "();\n\n";
    
    // Native property accessors
    for (const auto& prop : classInfo_.properties) {
        oss << "    " << prop.getCPPTypeName(*static_cast<const UETypeConverter*>(nullptr)) << " Get" << prop.name << "() const;\n";
        if (!prop.isEditable()) {
            oss << "    void Set" << prop.name << "(" << prop.getCPPTypeName(*static_cast<const UETypeConverter*>(nullptr)) << " Value);\n";
        }
        oss << "\n";
    }
    
    // Native function implementations
    for (const auto& func : classInfo_.functions) {
        oss << "    " << func.getSignature(*static_cast<const UETypeConverter*>(nullptr)) << ";\n\n";
    }
    
    oss << "private:\n";
    oss << "    NativeClass* NativeObject;\n";
    oss << "};\n";
    
    return oss.str();
}

std::unique_ptr<UClassBindingBase> UClassBindingFactory::createBinding(
    const UEClassInfo& classInfo,
    const UEBindingContext& context) {
    
    DiagnosticEngine::get().info("Creating class binding for: " + classInfo.name);
    
    // For now, create a generic binding
    // In a real implementation, this would use templates or reflection
    // to create the appropriate typed binding
    
    auto binding = std::make_unique<UClassBindingBase>(classInfo);
    configureTypedBinding(binding.get(), context);
    
    return binding;
}

template<typename NativeClass, typename KiwiClass>
std::unique_ptr<UClassBinding<NativeClass, KiwiClass>>
UClassBindingFactory::createTypedBinding(const UEClassInfo& classInfo,
                                        const UEBindingContext& context) {
    auto binding = std::make_unique<UClassBinding<NativeClass, KiwiClass>>(classInfo);
    configureTypedBinding(binding.get(), context);
    return binding;
}

void UClassBindingFactory::configureTypedBinding(UClassBindingBase* binding,
                                                const UEBindingContext& context) {
    if (!binding || !context.registry) {
        return;
    }
    
    DiagnosticEngine::get().info("Configuring typed binding for class: " + binding->getClassInfo().name);
    
    // Generate default property accessors
    generateDefaultPropertyAccessors(binding, context);
    
    // Generate default function invokers
    generateDefaultFunctionInvokers(binding, context);
}

void UClassBindingFactory::generateDefaultPropertyAccessors(UClassBindingBase* binding,
                                                           const UEBindingContext& context) {
    // This would generate default getters and setters for properties
    // based on reflection data
    
    DiagnosticEngine::get().info("Generating default property accessors");
}

void UClassBindingFactory::generateDefaultFunctionInvokers(UClassBindingBase* binding,
                                                          const UEBindingContext& context) {
    // This would generate default function invokers
    // based on function signatures
    
    DiagnosticEngine::get().info("Generating default function invokers");
}

// Explicit template instantiations for common types
template class UClassBinding<UObject, void>;
template class UClassBinding<AActor, void>;
template class UClassBinding<APawn, void>;
template class UClassBinding<ACharacter, void>;

} // namespace Unreal
} // namespace kiwiLang